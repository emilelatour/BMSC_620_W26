{
  "hash": "faca0749b70e53c0b14e0575cb1b5f5c",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Muddy Points\"\nsubtitle: \"Categorical Data and R Basics\"\ndate-modified: \"today\"\nformat:\n  html:\n    toc: true\n---\n\n\n\n## Thanks for the feedback\n\nThank you to everyone who submitted post-class feedback. The comments were thoughtful and specific, which is incredibly helpful for improving pacing and clarity.\n\nBelow I’ve grouped the most common muddy points into a few themes and addressed each one.\n\n## A note on pacing\n\nSeveral comments mentioned that the end of class felt rushed, particularly around functions, R packages, and libraries.\n\nI tried to cover too much in the final 15 minutes, and that made it hard to follow along, especially if you encountered any errors or needed to catch up.\n\n### What the pacing feedback shows\n\nLooking at the post-class survey:\n\n- 53% felt the pace was about right\n- 33% felt it was slightly too fast\n- 13% felt it was slightly too slow\n\nThis tells me that while the overall pace worked for many of you, a significant portion found it too fast, especially toward the end.\n\n### Going forward\n\nI'll adjust by:\n\n- Leaving more buffer time at the end of class rather than rushing to cover everything\n- Slowing down when introducing new R functions\n- Giving you more time to type along and troubleshoot errors as they come up\n- Being more intentional about what's \"essential for now\" vs. \"we'll revisit this later\"\n\nThe reality is that R has a learning curve, especially if you're new to programming. Some of the functions we covered (like `seq()` or inspecting datasets) were meant as examples or reference material, not things you need to master immediately.\n\n### What you can do\n\nIf the pace feels too fast:\n\n- Focus on running the code and getting it to work, even if you don't fully understand every detail yet\n- Use the help system (`?function_name`) to review functions after class\n- Come to office hours or reach out if something didn't click\n- Remember that we'll be using these same tools repeatedly, so you'll get more comfortable with practice\n\nThanks for the honest feedback. It helps me calibrate for future classes.\n\n## Why does Quarto sometimes say \"object not found\" even though I assigned it?\n\nSeveral people described seeing an error like:\n\n`Error: object 'x' not found`\n\neven though the code that creates the object appears earlier in the Quarto document.\n\nThis usually happens because **code chunks have not been run in order**.\n\nKey points:\n\n- An object only exists if the chunk that creates it has actually been executed\n- Writing code in a Quarto document does not automatically run it\n- If a later chunk runs before an earlier one, R will report \"object not found\"\n- Restarting R or opening a new session clears all previously created objects\n\nWhen the error suddenly disappears, it is usually because:\n\n- you ran an earlier chunk\n- you rendered the document from the top\n- or you ran all chunks in order\n\n<!-- We will spend time in class discussing how to run chunks, restart sessions, and diagnose this type of error. -->\n\n## `View()` vs `view()` in R\n\nSeveral people ran into an error like:\n\n`Error in view(iris) : could not find function \"view\"`\n\nThis happens because **R is case-sensitive**.\n\nIn R:\n\n- `View()` (capital V) is a built-in RStudio function that opens a data viewer\n- `view()` (lowercase v) does not exist, so R throws an error\n\nFor example:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nView(iris)   # works\nview(iris)   # error\n```\n:::\n\n\n\nThis is a common early mistake and nothing to worry about. Many R functions rely on exact capitalization, so even small differences in case can cause errors.\n\nIf you see an error saying a function \"could not be found,\" one of the first things to check is whether the function name is spelled and capitalized correctly.\n\n## Understanding function arguments: the `seq()` example \n\nOne muddy point was about understanding what `from = 1, to = 12, by = 3` means in the `seq()` function.\n\nThis is actually a great question because it gets at how **all** R functions work, not just `seq()`.\n\n### What `seq()` does\n\nThe `seq()` function generates a sequence of numbers. For example:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nseq(from = 1, to = 12, by = 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  1  4  7 10\n```\n\n\n:::\n:::\n\n\n\nThis creates a sequence that:\n\n- Starts at 1 (`from = 1`)\n- Ends at 12 (`to = 12`)\n- Increases by 3 each step (`by = 3`)\n\nSo you get: 1, 4, 7, 10\n\n### Argument order doesn't matter when you name them\n\nOne key point about R functions: when you **name** the arguments, the order doesn't matter:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nseq(from = 1, to = 12, by = 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  1  4  7 10\n```\n\n\n:::\n\n```{.r .cell-code}\nseq(by = 3, to = 12, from = 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  1  4  7 10\n```\n\n\n:::\n:::\n\n\n\nBoth produce exactly the same result because R knows which value goes with which argument.\n\n### When you don't name them, argument order does matter\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nseq(1, 12, 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  1  4  7 10\n```\n\n\n:::\n\n```{.r .cell-code}\nseq(3, 12, 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  3  4  5  6  7  8  9 10 11 12\n```\n\n\n:::\n:::\n\n\n\n### How to learn about any function\n\nThe most important takeaway: whenever you see a function you don't recognize (or want to remember how it works), use the help system:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n?seq\n```\n:::\n\n\n\nThis will show you:\n\n- What arguments the function takes\n- What each argument means\n- Examples of how to use it\n\n**This works for any function in R.** Get in the habit of typing `?function_name` whenever you're unsure.\n\n### Why I used `seq()` as an example\n\nI used `seq()` not because you need to memorize it for this class, but to illustrate how functions work in general: they take named inputs (arguments) and produce outputs. The specific function doesn't matter as much as understanding that pattern.\n\n\n## Why assign objects (`b <- c(3:10)`) instead of just running code?\n\nThis was a great question and came up because I ran `c(3:10)` live in class.\n\nI used that line **only to demonstrate what the c()** function does, and to show that in this case it produces the same result as `3:10`. It was not meant to be an example of analysis code you would normally write.\n\nIn general: \n\n- `c(3:10)` creates a vector and prints it to the console\n- `b <- c(3:10)` creates the same vector **and stores it** so it can be reused later\n\nAssigning objects allows you to:\n- reuse results\n- build analyses step-by-step\n- debug your work\n- write reproducible code\n\nIn practice, almost everything we do in R involves creating objects and then working with them. When you see code run without assignment, it is usually just for demonstration or quick inspection.\n\n## Inspecting a new dataset: how to apply this to your own data\n\nOne comment noted that the dataset inspection portion felt unclear, especially in terms of how to apply it to a dataset of your own.\n\nThat's completely understandable. The goal of those functions is not to memorize them, but to develop a **consistent first step** whenever you load or receive a new dataset.\n\nWhen you read in *any* dataset, a good default workflow is:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndim(data)\nnames(data)\nstr(data)\nhead(data)\ntail(data)\n```\n:::\n\n\n\nEach of these answers a different, important question:\n\n- `dim()` – How many rows and columns are there?\n- `names()` – What are the variable (column) names?\n- `str()` – What type of data is each variable (numeric, character, factor, etc.)?\n- `head()` / `tail()` – What do the first or last few rows actually look like?\n\nTogether, these help you understand:\n\n- what information you have\n- how variables are stored\n- whether the data look like you expect them to\n\nYou can think of this as the R equivalent of \"opening a spreadsheet and scrolling around,\" but in a more systematic and reproducible way.\n\nGoing forward, when you work with your own datasets (for homework or projects), these should be the **first things you run** after importing data.\n\n\n\n## Proportion tables: why `prop.table(iris$Species)` gives an error\n\nOne question came up at the end of class about the following error:\n\n```\nError in Summary.factor(…):\n'sum' not meaningful for factors\n```\n\nThis happened when running:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprop.table(iris$Species)\n```\n:::\n\n\n\nThe key issue is that `prop.table()` expects a table as its input, not a raw column or vector.\n\nYou can see this in the help file:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n?prop.table\n```\n:::\n\n\n\nThe first argument to `prop.table()` should be a table of counts, which is usually created with `table()`.\n\nFor example:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntable(iris$Species)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n    setosa versicolor  virginica \n        50         50         50 \n```\n\n\n:::\n:::\n\n\n\ncreates a table of counts for each species. Then:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprop.table(table(iris$Species))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n    setosa versicolor  virginica \n 0.3333333  0.3333333  0.3333333 \n```\n\n\n:::\n:::\n\n\n\ncomputes the proportions.\n\nWhen you run:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprop.table(iris$Species)\n```\n:::\n\n\n\nR tries to treat the factor as if it were numeric and attempts to compute sums internally, which leads to the error:\n\n```\n'sum' not meaningful for factors\n```\n\nSo the fix is not about changing the data, but about giving the function the type of object it expects.\n\nA good general pattern to remember is:\n\n* First, create a table of counts with `table()`\n* Then, compute proportions with `prop.table()`\n\n## Why nest functions like `prop.table(table(x))`?\n\nOne question was: \"Why are the nested table functions necessary? Is there a cleaner way to code this?\"\n\nThis is a great question about R's design philosophy.\n\n### Why the nesting is necessary\n\nEach function does **one specific job**:\n\n- `table()` creates a frequency table (counts)\n- `prop.table()` converts counts to proportions\n\nR's approach is to have many small, focused functions that do one thing well, rather than fewer functions that try to do everything.\n\nSo to get proportions, you need:\n\n1. First, count the frequencies: `table(x)`\n2. Then, convert to proportions: `prop.table(table(x))`\n\n### Is there a cleaner way?\n\nYou could save the intermediate step to make it more readable:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Option 1: nested (what we've been doing)\nprop.table(table(iris$Species))\n\n# Option 2: save intermediate step\nspecies_counts <- table(iris$Species)\nspecies_props <- prop.table(species_counts)\nspecies_props\n```\n:::\n\n\n\nOption 2 is more verbose but can be easier to read and debug, especially when you're learning.\n\n### The tidyverse approach\n\nLater in the course, we'll learn the `dplyr` package, which has functions that work differently and can feel more intuitive:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\n\niris %>%\n  count(Species) %>%\n  mutate(proportion = n / sum(n))\n```\n:::\n\n\n\nThis reads more like English: \"take iris, count by Species, then calculate proportions.\"\n\n### For now\n\nThe `table()` and `prop.table()` approach is the base R way and is worth learning because:\n\n- It works without any packages\n- It's widely used\n- Understanding it helps you understand R's function design\n\nBut I hear you that the nesting can feel awkward. We'll see other approaches as the course progresses.\n\n## Marginal vs. Conditional Distributions\n\nOne muddy point was about the difference between marginal and conditional distributions.\n\nThis is a really important distinction, so let's break it down with a concrete example.\n\n### A Simple Example: Gender and Smoking Status\n\nImagine we have data on 100 people, classified by gender and smoking status:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create example data\nsmoking_data <- matrix(c(15, 35, 25, 25), \n                       nrow = 2,\n                       dimnames = list(\n                         Gender = c(\"Male\", \"Female\"),\n                         Smoker = c(\"Yes\", \"No\")\n                       ))\nsmoking_data\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n        Smoker\nGender   Yes No\n  Male    15 25\n  Female  35 25\n```\n\n\n:::\n:::\n\n\n\n### Marginal Distribution: Looking at ONE variable\n\n**Marginal distributions** answer questions like: \"What proportion of our sample is male?\" or \"What proportion smokes?\"\n\nYou get these by summing across rows or columns:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Marginal distribution for Gender (sum across columns)\nrowSums(smoking_data)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  Male Female \n    40     60 \n```\n\n\n:::\n\n```{.r .cell-code}\n# As proportions\nprop.table(rowSums(smoking_data))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  Male Female \n   0.4    0.6 \n```\n\n\n:::\n:::\n\n\n\nThis tells us: 40% of our sample is male, 60% is female. **We're ignoring smoking status entirely.**\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Marginal distribution for Smoker (sum across rows)\ncolSums(smoking_data)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nYes  No \n 50  50 \n```\n\n\n:::\n\n```{.r .cell-code}\n# As proportions\nprop.table(colSums(smoking_data))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nYes  No \n0.5 0.5 \n```\n\n\n:::\n:::\n\n\n\nThis tells us: 50% of our sample smokes, 50% doesn't. **We're ignoring gender entirely.**\n\n### Conditional Distribution: Looking at relationships\n\n**Conditional distributions** answer questions like: \"Among males, what proportion smokes?\" or \"Among smokers, what proportion is male?\"\n\nYou calculate these within a specific row or column:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Conditional distribution of smoking GIVEN gender\n# (proportions within each row)\nprop.table(smoking_data, margin = 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n        Smoker\nGender         Yes        No\n  Male   0.3750000 0.6250000\n  Female 0.5833333 0.4166667\n```\n\n\n:::\n:::\n\n\n\nThis tells us:\n\n- Among males: 38% smoke, 63% don't\n- Among females: 58% smoke, 42% don't\n\nThis is **P(Smoker | Gender)** — the probability of smoking *given* someone's gender.\n\n### The Key Difference\n\n- **Marginal**: What's the overall distribution of one variable? (Ignores other variables)\n- **Conditional**: What's the distribution of one variable *within a specific group* of another variable? (Shows relationships)\n\n### Why This Matters\n\nConditional distributions let you see if variables are related:\n\n- If smoking rates are the same for males and females, gender and smoking might be independent\n- If smoking rates differ by gender, there's a relationship between these variables\n\nWe'll use this concept throughout the course when we talk about associations and relationships between variables.\n\n## Installing packages: what does \"comment it out\" mean?\n\nOne muddy point was about what I meant when I said to \"code it out\" after installing a package. \n\nI thought I said \"**comment** it out\" (at least I meant to), which is R terminology for turning code into a comment so it doesn't run anymore.\n\n### The workflow for installing packages\n\nHere's the typical workflow:\n\n**Step 1: Install the package (only once)**\n\nWhen you first need a package, you install it:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages(\"ggplot2\")\n```\n:::\n\n\n\n**Step 2: Comment it out after installation**\n\nAfter the package is installed on your computer, you add a `#` at the beginning of that line to turn it into a comment:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# install.packages(\"ggplot2\")\n```\n:::\n\n\n\nThis way:\n\n- The code is still visible in your script (you remember what package you needed)\n- But it won't run every time you run your script (since it's already installed)\n- If someone else uses your script, they can see what packages are needed and uncomment it if needed\n\n**Step 3: Load the package (every time)**\n\nAt the top of your script, you load the package every time you use it:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ggplot2)\n```\n:::\n\n\n\n### Why comment instead of delete?\n\nYou could delete the `install.packages()` line entirely, but commenting it out is often better because:\n\n- It documents what packages your script needs\n- If you share your script with someone else, they can see what to install\n- If you need to reinstall R or use a different computer, you have a record\n\n### Summary\n\n- `install.packages()` → run once, then **comment out** with `#`\n- `library()` → include at the top of every script, runs every time\n\nSorry for any confusion with my wording in class!\n\n## Package conflicts: how often is this a problem?\n\nOne question was: \"How often will it be a problem installing R packages that break other R packages?\"\n\nGood news: **this is rare in practice**, especially with the packages we'll use in this course.\n\n### When conflicts happen\n\nThe most common \"conflict\" you'll see isn't packages breaking each other, but rather two packages having functions with the same name. For example:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\nlibrary(MASS)\n```\n:::\n\n\n\nBoth packages have a function called `select()`. When you load both, R will warn you:\n```\nThe following object is masked from 'package:dplyr':\n    select\n```\n\nThis means the `select()` from the package loaded second (MASS) will be used by default.\n\n### How to handle this\n\nIf you need a specific version of a function, you can specify the package explicitly:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndplyr::select()  # uses dplyr's version\nMASS::select()   # uses MASS's version\n```\n:::\n\n\n\n### Bottom line\n\n- True package incompatibility (where one package actually breaks another) is uncommon\n- Function name conflicts are more common but easy to manage\n- R will warn you when conflicts occur\n- For this course, the packages we use are all compatible with each other\n\nDon't worry about this as you're getting started. If a conflict comes up, we'll address it together.\n\n## Working directories and file locations\n\nQuestions came up about:\n\n- what your working directory is\n- how it differs from where files are saved\n- why errors appear when setting directories\n\nWe'll cover this more carefully soon, especially once we start importing data and working with multiple files.\n\nWhen working with a Quarto document (`.qmd`) like in the homework, your working directory will be wherever you have the `.qmd` saved and RStudio should produce the `.html` file there. For what we've been learning in R you shouldn't have to worry about working directories yet. \n\nWe'll cover this more once we start importing data and working with multiple files.\n\n\n\n\n\n\n\n\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}