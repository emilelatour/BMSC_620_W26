{
  "hash": "332144fc9d8d0d38949bd68004a69052",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Muddy Points\"\nsubtitle: \"Exploratory Data Analysis and Data Visualization\"\ndate-modified: \"today\"\nformat:\n  html:\n    toc: true\n  pdf: default\n---\n\n\n\n\n\n\n## Thanks for the feedback\n\nThank you to everyone who submitted post-class feedback. I'm pleased to see that so many of you found the live coding helpful, and I appreciate the specific questions about R syntax, packages, and workflow.\n\n## A note on pacing\n\nLooking at the post-class survey for this lecture:\n\n- 77.8% felt the pace was about right\n- 14.8% felt it was slightly too fast\n- 7.4% felt it was slightly too slow\n\nThis is excellent feedback overall. The strong central tendency around \"about right\" suggests the material was well-calibrated for the class level. For those who found the pace slightly too fast, remember that:\n\n- The lectures are recorded and you can rewatch sections\n- The .qmd files are available for you to work through at your own pace\n- The homework gives you extended practice time with these concepts\n- **The in-class examples directly mirror the homework structure** — if you can follow the class examples, you have the scaffolding you need\n\n## Connection between class examples and homework\n\nSeveral of you mentioned wanting examples that follow exactly what you'll need for homework. Good news: **that's exactly what the in-class examples are designed to do**.\n\nThe in-class .qmd file is a template for the homework. When you're working through homework problems, refer back to the class examples — you'll see the same patterns (filter → select → summarize, building ggplots step-by-step, using pipes to chain operations).\n\nGoing forward, I'll be more explicit about this connection:\n\n- \"This pattern of piping filter → select → summarize? You'll use this exact structure in homework problem X.\"\n- \"Notice how we're building this ggplot layer by layer — you'll follow this same approach for your visualizations.\"\n\n## Packages: what you need and when\n\nSeveral questions came up about R packages. Let me clarify:\n\n### What are packages?\n\nPackages are collections of functions that extend R's capabilities. Think of base R as a smartphone, and packages as apps you install to do specific tasks.\n\n### The packages we're using in this course\n\nFor this course, you need these packages installed:\n\n- **tidyverse** (this actually installs several packages including dplyr, ggplot2, and others)\n- **janitor** (for the `adorn_` functions)\n\nThat's it for now. I'll let you know when we need additional packages.\n\n### Install once, load each session\n\nThis is a common source of confusion:\n\n**Installation** (do this once per computer):\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages(\"tidyverse\")\ninstall.packages(\"janitor\")\n```\n:::\n\n\n\n\n\n\n**Loading** (do this once per R session):\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(janitor)\n```\n:::\n\n\n\n\n\n\nThink of it like this:\n\n- **Installing** is like downloading an app to your phone (do once)\n- **Loading with `library()`** is like opening that app (do every time you restart R)\n\n### Why do we need `library()` every session?\n\nYes, you need to run `library(package_name)` at the start of every R session (or at the top of every script/Quarto document). This tells R which packages you want to use for this particular analysis.\n\nIt might seem redundant, but it's actually helpful because:\n\n- It makes your code more reproducible (others know exactly which packages you're using)\n- It avoids conflicts when different packages have functions with the same name\n- It keeps R's memory usage lower by only loading what you need\n\n## R syntax: commas, quotes, and spacing\n\nSeveral of you mentioned confusion with R syntax, especially around commas and quotes. This is completely normal — these small details take practice.\n\n### Common syntax patterns\n\n**Function arguments are separated by commas:**\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Correct\nsummarize(data, mean_value = mean(x), median_value = median(x))\n\n# Incorrect - missing comma between arguments\nsummarize(data, mean_value = mean(x) median_value = median(x))\n```\n:::\n\n\n\n\n\n\n**Column names usually don't need quotes in tidyverse:**\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Both work in tidyverse functions\nselect(data, Species, Sepal.Length)\nselect(data, \"Species\", \"Sepal.Length\")\n\n# But unquoted is more common and easier to type\n```\n:::\n\n\n\n\n\n\n**Spacing doesn't usually matter:**\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# These are equivalent\nx <- mean(y)\nx<-mean(y)\nx  <-  mean(  y  )\n```\n:::\n\n\n\n\n\n\n### When you get an \"unexpected\" error\n\nIf you get an error like \"unexpected ',' in...\" or \"unexpected ')' in...\", it usually means:\n\n- Missing or extra comma\n- Missing or extra parenthesis\n- Unmatched quotes\n\n**Debugging tip:** Look at the line number in the error message, then carefully check that line for:\n\n1. Equal number of opening `(` and closing `)`\n2. Commas between function arguments\n3. Matching quotes (every `\"` has a closing `\"`)\n\n### Code that was missing from class notes\n\nOne comment noted that some code pieces were missing from the class notes (like needing to reload packages). You're absolutely right — for people new to R, it's confusing when code doesn't run because a package wasn't loaded.\n\nGoing forward, I'll make sure the .qmd files are complete and runnable from top to bottom, including all necessary `library()` calls at the beginning.\n\n## Understanding pipes: more than just readability\n\nOne question was: \"Pipes. Do they just help the readability and flow of your code?\"\n\nGreat question! The short answer is: **primarily yes, but they also help you avoid creating intermediate objects**.\n\n### What pipes do\n\nThe pipe operator `%>%` takes the output from one function and passes it as the first argument to the next function.\n\n**Without pipes** (nested functions, read inside-out):\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummarize(\n  filter(\n    select(iris, Species, Sepal.Length),\n    Sepal.Length > 5\n  ),\n  mean_length = mean(Sepal.Length)\n)\n```\n:::\n\n\n\n\n\n\n**With pipes** (read top to bottom):\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\niris %>%\n  select(Species, Sepal.Length) %>%\n  filter(Sepal.Length > 5) %>%\n  summarize(mean_length = mean(Sepal.Length))\n```\n:::\n\n\n\n\n\n\n### Why pipes matter\n\n1. **Readability**: You can read the code in the order operations happen (like reading a recipe)\n2. **Avoid intermediate objects**: You don't need to save temporary results\n3. **Easier to modify**: You can add or remove steps without restructuring everything\n\n**Without pipes, you'd need intermediate objects:**\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstep1 <- select(iris, Species, Sepal.Length)\nstep2 <- filter(step1, Sepal.Length > 5)\nstep3 <- summarize(step2, mean_length = mean(Sepal.Length))\n```\n:::\n\n\n\n\n\n\n**With pipes, it's one continuous flow:**\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nresult <- iris %>%\n  select(Species, Sepal.Length) %>%\n  filter(Sepal.Length > 5) %>%\n  summarize(mean_length = mean(Sepal.Length))\n```\n:::\n\n\n\n\n\n\nSo while readability is the main benefit, pipes also make your code more concise and easier to maintain.\n\n## Chaining dplyr verbs: when and how\n\nOne comment: \"I'm a little confused on how to correctly chain dplyr verbs and when it is necessary to chain something\"\n\n### When to chain\n\nYou chain dplyr verbs (using pipes) when you want to perform multiple operations in sequence on the same dataset.\n\n**Chain when operations are related:**\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Good use of chaining - logical sequence\niris %>%\n  filter(Species == \"setosa\") %>%        # First, filter to one species\n  select(Sepal.Length, Sepal.Width) %>%  # Then, select specific columns\n  summarize(mean_length = mean(Sepal.Length))  # Finally, calculate summary\n```\n:::\n\n\n\n\n\n\n**Don't chain when operations are independent:**\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# These are separate analyses, don't chain them\nsetosa_summary <- iris %>%\n  filter(Species == \"setosa\") %>%\n  summarize(mean_length = mean(Sepal.Length))\n\nversicolor_summary <- iris %>%\n  filter(Species == \"versicolor\") %>%\n  summarize(mean_length = mean(Sepal.Length))\n```\n:::\n\n\n\n\n\n\n### How to chain correctly\n\nEach verb in the chain:\n\n1. Takes the result from the previous step as its first argument (automatically via `%>%`)\n2. Returns a modified data frame\n3. Passes that data frame to the next verb\n\n**The pattern:**\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata %>%\n  verb1(arguments) %>%\n  verb2(arguments) %>%\n  verb3(arguments)\n```\n:::\n\n\n\n\n\n\n### Common chaining patterns you'll use\n\n**Filter → Select → Summarize:**\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata %>%\n  filter(condition) %>%      # Reduce rows\n  select(columns) %>%        # Reduce columns\n  summarize(statistic)       # Calculate summary\n```\n:::\n\n\n\n\n\n\n**Group → Summarize:**\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata %>%\n  group_by(category) %>%     # Define groups\n  summarize(mean = mean(x))  # Calculate within each group\n```\n:::\n\n\n\n\n\n\n**Filter → Mutate:**\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata %>%\n  filter(condition) %>%      # Subset the data\n  mutate(new_col = x + y)    # Add a new column\n```\n:::\n\n\n\n\n\n\nYou'll practice these patterns extensively in the homework.\n\n## Understanding adorn functions\n\nOne comment: \"I got a little lost with how Adorn works but I think I figured out my issue after reviewing the notes.\"\n\nI'm glad you figured it out! For others who might still be unclear:\n\n### What adorn functions do\n\nThe `adorn_` functions from the `janitor` package add nice formatting to tables, especially frequency tables created with `tabyl()` or `count()`.\n\n**Common adorn functions:**\n\n- `adorn_totals()` — adds row/column totals\n- `adorn_percentages()` — converts counts to proportions\n- `adorn_pct_formatting()` — formats proportions as percentages (e.g., \"25.0%\" instead of 0.25)\n- `adorn_ns()` — adds counts alongside percentages\n\n### How to use them\n\nAdorn functions are meant to be **chained** (using pipes) after you create a table:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\niris %>%\n  count(Species) %>%               # Create frequency table\n  adorn_totals(\"row\") %>%          # Add total row\n  adorn_percentages(\"col\") %>%     # Convert to proportions\n  adorn_pct_formatting(digits = 1) # Format as percentages\n```\n:::\n\n\n\n\n\n\n### The order matters\n\nApply adorn functions in this sequence:\n\n1. `adorn_totals()` — add totals first\n2. `adorn_percentages()` — then convert to proportions\n3. `adorn_pct_formatting()` — then format the display\n4. `adorn_ns()` — optionally add counts in parentheses\n\nIf you do them out of order (like formatting before calculating percentages), you'll get errors or unexpected results.\n\n## Too many options vs. one clear path\n\nOne insightful comment: \"It is confusing for people who are starting out to hear multiple options of how to do something. It may be more helpful to have examples that we work through that follow exactly what we will need to be able to do to complete the homework and master tasks.\"\n\nThis is excellent feedback. I want to address this directly:\n\n### My teaching approach and why\n\nI tend to mention alternative approaches because:\n\n- I want you to recognize different coding styles when you see them online or in others' code\n- Some of you have prior R experience and benefit from seeing connections\n- It helps build conceptual understanding of why we do things a certain way\n\n### But I hear you\n\nFor those new to R, multiple options can be overwhelming when you're just trying to learn **one** way that works.\n\n### What I'll do differently\n\nGoing forward, I'll use a **core path + alternatives** approach:\n\n1. **Teach one clear method first** — this is the \"homework way\"\n2. **Practice that method** with multiple examples\n3. **Briefly mention alternatives** only after the core method is solid, clearly labeling them as \"you might also see...\" rather than \"you could also do...\"\n\nFor example:\n\n> \"For this course, we'll use `library(tidyverse)` at the start of our scripts. You might also see people use `require()` or load packages individually like `library(dplyr)`, but we'll stick with `library(tidyverse)` for consistency.\"\n\nThis way, you have a clear, reliable approach for homework while still being aware that other methods exist.\n\n## Live coding pace and practical adjustments\n\nSeveral comments mentioned the pace of live coding:\n\n- \"The class just felt fast and if there were any errors in my code, we had already moved on before I could see what the issue was.\"\n- \"The R stuff is still a little fast for me, especially with how small the screen is\"\n- \"We just moved very quickly through everything but still didn't finish the entire lecture\"\n\nThese are all valid concerns. Here's what I'll adjust for our next R-heavy session:\n\n### Pacing changes\n\n1. **Built-in debug time**: After complex examples, I'll pause for 1-2 minutes and ask \"Anyone getting an error? Let me know in chat or raise your hand\"\n2. **Slower typing**: I'll be more deliberate about typing speed, especially for syntax-heavy sections\n3. **Finish or cut strategically**: Rather than rushing to finish all slides, I'll plan to end at a logical stopping point, even if we don't cover everything\n\n### Visual improvements\n\n1. **Larger font in RStudio**: I'll increase the font size for better visibility\n2. **Clear transitions**: I'll announce when switching between slides and RStudio (e.g., \"Now I'm opening RStudio...\")\n3. **Zoom on key areas**: When typing complex syntax, I'll zoom in on the code\n\n### Managing package installation delays\n\nOne comment: \"Installing data packages always takes a few minutes or longer if there's an error. It seems instantaneous on your screen, and I'd hate to fall behind while waiting for something to load.\"\n\nYou're absolutely right. Here's what we'll do:\n\n1. **Pre-class package list**: I'll post which packages to install before class\n2. **Buffer time in class**: When we do install packages during class, I'll build in 3-5 minutes of buffer time\n3. **Acknowledge the wait**: I'll explain that package installation takes time and that it's normal\n\n## Practice makes perfect: the role of homework\n\nOne comment really captured the learning process well: \"I think I just need some practice with all of the R code that we went over in class, it all feels pretty muddy at this point but I think working with it and doing more examples and making mistakes will help me make sense of it.\"\n\nThis is exactly right! Another comment echoed this: \"The lecture material is helpful but I have trouble following the in class coding examples. I have to work through the homework in order to fully grasp concepts.\"\n\n### This is normal and expected\n\nLive coding in class is designed to:\n\n- Show you what's possible\n- Demonstrate the workflow\n- Give you examples to reference\n- Provide scaffolding for homework\n\nIt is **not** expected that you'll master everything during the live demo. Real learning happens when you:\n\n- Work through homework problems at your own pace\n- Make mistakes and debug them\n- Apply concepts to different datasets\n- Rewatch recorded sections when needed\n\n### The class-homework connection\n\nThe in-class examples are **templates** for the homework. When you're stuck on homework, go back to the .qmd file from class and look for a similar pattern.\n\nFor example:\n\n- **Homework asks**: Calculate mean Sepal.Length by Species\n- **Class example showed**: Calculate mean bill_length by species (for penguins data)\n- **Pattern is the same**: `group_by(category) %>% summarize(mean = mean(variable))`\n\n### If you're feeling lost during class\n\nThat's okay! Your strategies should be:\n\n1. **Watch and absorb** rather than trying to type everything perfectly in real-time\n2. **Use the .qmd file** as your reference when doing homework\n3. **Rewatch recordings** for sections that went too fast\n4. **Come to office hours** with specific questions from homework\n\nOne student noted: \"doing the homework was far more informative\" — this isn't a criticism of lecture, it's recognition that **doing** is how we learn coding. Lecture provides the framework; homework provides the practice.\n\n## What's working well\n\nMany of you identified clear points that I want to acknowledge and continue:\n\n### The .qmd file for following along\n\nMultiple comments mentioned how helpful it was to have the Quarto document to code along with. I'll continue providing complete, runnable .qmd files for every R session.\n\n### Real-world examples and explanations\n\nSeveral of you appreciated:\n\n- The pipe operator analogy (keys, driving to work)\n- Learning the history and context of packages\n- Understanding how functions answer specific questions\n\nI'll continue using concrete analogies and providing the \"why\" behind our tools.\n\n### Step-by-step building\n\nYou valued seeing how to construct things incrementally (especially ggplots). This scaffolded approach works well, so I'll maintain this pattern.\n\n## Looking ahead\n\nBased on your feedback, I'll:\n\n1. Start with a clear list of required packages (posted before class)\n2. Make the connection between class examples and homework more explicit\n3. Use the \"core path + alternatives\" approach to avoid overwhelming you with options\n4. Build in debug/catch-up time during live coding\n5. Focus on finishing a coherent chunk of material rather than rushing through all slides\n\nThank you again for the thoughtful feedback. These muddy points help me teach more effectively, and your willingness to identify what's confusing is exactly what makes this process work.\n",
    "supporting": [
      "08_eda_and_dataviz_muddy_points_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": null,
    "postProcess": false
  }
}