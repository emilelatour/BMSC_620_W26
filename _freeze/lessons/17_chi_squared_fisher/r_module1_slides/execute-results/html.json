{
  "hash": "5b78cd3f805e85a8b1964cd462a71fbd",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"R Module 1: Reproducible Reports in Quarto\"\nsubtitle: \"BMSC 620 | R Workflow Series\"\nauthor: \"Emile Latour\"\nformat:\n  revealjs:\n    theme: \"../../assets/css/reveal-bmsc620_v5.scss\"\n    slide-number: true\n    show-slide-number: all\n    width: 1955\n    height: 1100\n    footer: \"BMSC 620 | Inference for Proportions\"\n    html-math-method: mathjax\n    chalkboard: true\n    progress: true\n    code-line-numbers: true\n    code-copy: true\n    highlight-style: github\n    fig-align: center\n    incremental: false\nexecute:\n  echo: true\n  warning: false\n  message: false\n---\n\n::: {.cell}\n\n:::\n\n\n\n\n## What We're Learning Today {.section-slide}\n\n::: {.learning-objectives}\nBy the end of this module, you will be able to:\n\n1. Understand and modify the **YAML header** in a `.qmd` file\n2. Use **chunk options** to control how code and output appear\n3. Insert **R results directly into prose** using inline R\n4. Produce a report where numbers never need to be manually copy-pasted\n:::\n\n::: {.callout-note}\nThese skills apply directly to every homework and future manuscript you write.\n:::\n\n---\n\n## The Problem We're Solving\n\nImagine you run an analysis and write up your results:\n\n> \"The mean BMI in our sample was **27.3** kg/m², with a standard deviation of **6.1**.\"\n\nThen your collaborator sends you a corrected dataset.\n\n. . .\n\nYou re-run your analysis. The mean is now **27.6**. The SD is now **6.3**.\n\n. . .\n\n**How many places in your report do you need to update?**\n\n. . .\n\n::: {.fragment .highlight-red}\nEvery. Single. One. Manually.\n:::\n\n---\n\n## The Solution: Reproducible Reporting\n\nWhat if your prose *was* your code?\n\n\n\n\n::: {.cell}\n\n```{.markdown .cell-code}\nThe mean BMI in our sample was `r mean(nhanes.samp$BMI, na.rm = TRUE) |> round(1)` kg/m²,\nwith a standard deviation of `r sd(nhanes.samp$BMI, na.rm = TRUE) |> round(1)`.\n```\n:::\n\n\n\n\n\\\n\nWhen the data changes, you re-render. **Everything updates.**\n\n> The mean BMI in our sample was 26.6 kg/m²,\nwith a standard deviation of 8.\n\n. . .\n\n\\\n\nThis is what Quarto makes possible — and it starts with understanding the structure of a `.qmd` file.\n\n---\n\n## Anatomy of a `.qmd` File {.section-slide}\n\nA Quarto document has three parts:\n\n::: {.columns}\n::: {.column width=\"50%\"}\n````\n---                     ← YAML header\ntitle: \"My Report\"\nformat: html\n---\n\nSome prose text       ← Markdown text\n\n```{{r}}              ← Code chunk\nmean(x)\n```\n````\n:::\n\n::: {.column width=\"50%\"}\n| Section | Purpose |\n|---------|---------|\n| **YAML** | Document settings and metadata |\n| **Prose** | Your writing (Markdown) |\n| **Chunks** | Your R code |\n\nAll three work together to produce your final document.\n:::\n:::\n\n---\n\n## Part 1: The YAML Header {.section-slide}\n\n---\n\n## What Is YAML?\n\nYAML = \"YAML Ain't Markup Language\" *(don't worry about the name)*\n\nIt lives between the two sets of `---` at the **very top** of your file.\n\n\n\n\n::: {.cell}\n\n```{.yaml .cell-code}\n---\ntitle: \"NHANES Sample Analysis\"\nauthor: \"Your Name\"\ndate: today\nformat: html\n---\n```\n:::\n\n\n\n\n::: {.callout-important}\n**YAML is indentation-sensitive.** Misaligned spaces will cause your document to fail to render. Always use spaces, not tabs.\n:::\n\n---\n\n## Essential YAML Fields\n\n\n\n\n::: {.cell}\n\n```{.yaml .cell-code}\n---\ntitle: \"NHANES Sample Analysis\"       # Document title\nsubtitle: \"BMSC 620 Homework 3\"       # Optional subtitle  \nauthor: \"Your Name\"                   # Your name\ndate: today                           # Auto-fills today's date\nformat: html                          # Output format\n---\n```\n:::\n\n\n\n\n\\\n\n`date: today` is a Quarto shortcut — it automatically uses the current date when you render. No more hardcoding dates.\n\n---\n\n## Controlling Your Output Format\n\nThe `format` field controls what kind of document is produced.\n\n::: {.columns}\n::: {.column width=\"50%\"}\n**Simple version:**\n\n\n\n::: {.cell}\n\n```{.yaml .cell-code}\nformat: html\n```\n:::\n\n\n\n:::\n\n::: {.column width=\"50%\"}\n**With options:**\n\n\n\n::: {.cell}\n\n```{.yaml .cell-code}\nformat:\n  html:\n    toc: true\n    toc-depth: 2\n    number-sections: true\n    theme: flatly\n    self-contained: true\n```\n:::\n\n\n\n:::\n:::\n\n. . .\n\n\\\n\n`self-contained: true` bundles everything into one `.html` file — **very useful for submitting homework.**\n\n---\n\n## Useful `format: html` Options\n\n| Option | What it does |\n|--------|-------------|\n| `toc: true` | Adds a table of contents |\n| `toc-depth: 2` | How many heading levels in the TOC |\n| `number-sections: true` | Numbers your section headings |\n| `theme: flatly` | Changes the visual theme |\n| `self-contained: true` | One file, easy to submit |\n| `code-fold: true` | Hides code by default (reader can expand) |\n\n---\n\n## Document-Level Execute Options\n\nYou can set default behavior for **all** code chunks in the YAML:\n\n\n\n\n::: {.cell}\n\n```{.yaml .cell-code}\n---\ntitle: \"NHANES Analysis\"\nformat: html\nexecute:\n  echo: true       # Show code by default\n  warning: false   # Hide warnings by default\n  message: false   # Hide package messages by default\n---\n```\n:::\n\n\n\n\n\\\n\n::: {.callout-tip}\nSetting `warning: false` and `message: false` at the document level is almost always a good idea. Individual chunks can override these defaults.\n:::\n\n---\n\n## Part 2: Chunk Options {.section-slide}\n\n---\n\n## What Are Chunk Options?\n\nChunk options control **how a specific chunk of code behaves** when the document renders.\n\nThey go at the top of a chunk using the `#|` prefix (the \"hashpipe\"):\n\n\n\n\n::: {.cell}\n\n````{.markdown .cell-code}\n```{{r}}\n#| label: my-analysis\n#| echo: false\n#| warning: false\n\nmean(nhanes.samp$BMI, na.rm = TRUE)\n```\n````\n:::\n\n\n\n\nEach `#|` line is one option. You can have as many as you need.\n\n---\n\n## The Most Important Chunk Options\n\n| Option | Values | What it controls |\n|--------|--------|-----------------|\n| `label` | any name | Names the chunk (useful for debugging) |\n| `echo` | `true/false` | Show the code in output? |\n| `eval` | `true/false` | Run the code? |\n| `warning` | `true/false` | Show warnings? |\n| `message` | `true/false` | Show messages? |\n| `include` | `true/false` | Include *anything* from this chunk? |\n\n---\n\n\n\n## `echo`: Show or Hide Code\n\n::: {.columns}\n::: {.column width=\"50%\"}\n**`echo: true`** — code and output both appear\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnhanes.samp %>% \n  summarise(\n    mean_bmi = mean(BMI, na.rm = TRUE) %>% round(1),\n    sd_bmi   = sd(BMI, na.rm = TRUE) %>% round(1)\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 2\n  mean_bmi sd_bmi\n     <dbl>  <dbl>\n1     26.6      8\n```\n\n\n:::\n:::\n\n\n\n:::\n\n::: {.column width=\"50%\"}\n**`echo: false`** — only the output appears\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 2\n  mean_bmi sd_bmi\n     <dbl>  <dbl>\n1     26.6      8\n```\n\n\n:::\n:::\n\n\n\n\n\\\n\n\\\n\n\\\n\n::: {.callout-tip}\nUse `echo: false` in polished reports where the code isn't the point — readers see only the result.\n:::\n:::\n:::\n\n---\n\n## `eval`: Run or Skip Code\n\n\n\n\n::: {.cell}\n\n````{.markdown .cell-code}\n```{{r}}\n#| eval: false\n\n# This code will be shown but NOT run\ninstall.packages(\"tidyverse\")\n```\n````\n:::\n\n\n\n\n\n\\\n\n::: {.callout-tip}\n`eval: false` is perfect for showing installation instructions or example code that you don't want to actually execute when rendering.\n:::\n\n---\n\n## `include`: Invisible but Active\n\n\n\n\n::: {.cell}\n\n````{.markdown .cell-code}\n```{r}\n#| label: setup-chunk\n#| include: false\n\n# This entire chunk — code AND output — is invisible in the final document\n# But the code still runs!\nlibrary(tidyverse)\nlibrary(oibiostat)\ndata(\"nhanes.samp\")\n```\n````\n:::\n\n\n\n\n`include: false` is what you use for your **setup chunk** — you need the libraries loaded, but readers don't need to see that.\n\n---\n\n## Chunk Options for Figures\n\n````markdown\n```{{r}}\n#| label: fig-bmi-hist\n#| fig-width: 7\n#| fig-height: 4\n#| fig-cap: \"Distribution of BMI in the NHANES sample (n = 200)\"\n#| fig-alt: \"Histogram showing a roughly normal distribution of BMI\"\n\nggplot(nhanes.samp, aes(x = BMI)) +\n  geom_histogram(bins = 30)\n```\n````\n\n| Option | Purpose |\n|--------|---------|\n| `fig-width` / `fig-height` | Dimensions in inches |\n| `fig-cap` | Caption below figure |\n| `fig-alt` | Accessibility alt text |\n\n---\n\n## Why Label Your Chunks?\n\n````markdown\n```{{r}}\n#| label: bmi-summary\n\nnhanes.samp |> \n  summarise(mean_bmi = mean(BMI, na.rm = TRUE))\n```\n````\n\nChunk labels help you in three ways:\n\n1. **Debugging** — error messages tell you exactly which chunk failed\n2. **Navigation** — RStudio shows labeled chunks in the document outline\n3. **Cross-referencing** — figures labeled `fig-*` can be cited in text\n\n::: {.callout-important}\nLabel names must be **unique** within a document and contain no spaces (use `-` or `_` instead).\n:::\n\n---\n\n## Part 3: Inline R {.section-slide}\n\n---\n\n## What Is Inline R?\n\nInline R lets you embed a **single R expression** directly inside your prose.\n\n\\\n\n**Syntax:**\n\n\n\n\n::: {.cell}\n\n```{.markdown .cell-code}\nThe sample includes `r nrow(nhanes.samp)` participants.\n```\n:::\n\n\n\n\n\\\n\n**Renders as:**\n\n> The sample includes 200 participants.\n\n\n\\\n\n\\\n\nThe backtick-r opens it, the closing backtick ends it. Everything between is evaluated as R.\n\n---\n\n## A Realistic Example\n\nSuppose you want to report summary statistics in a sentence:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# These are calculated in a code chunk\nn      <- nrow(nhanes.samp)\nm_bmi  <- mean(nhanes.samp$BMI, na.rm = TRUE) |> round(1)\nsd_bmi <- sd(nhanes.samp$BMI, na.rm = TRUE) |> round(1)\n```\n:::\n\n\n\n\n\n\\\n\n**In your qmd:**\n\n\n\n::: {.cell}\n\n```{.markdown .cell-code}\nThe NHANES sample included `r n` participants.\nMean BMI was `r m_bmi` kg/m² (SD = `r sd_bmi`).\n```\n:::\n\n\n\n\n\\\n\n**Rendered output:**\n\n> The NHANES sample included 200 participants. Mean BMI was 26.6 kg/m² (SD = 8).\n\n---\n\n## The Smart Workflow: Compute Then Report\n\nRather than putting complex expressions inline, **compute first in a chunk, then report inline.**\n\n\\\n\n::: {.columns}\n::: {.column width=\"50%\"}\n**❌ Hard to read:**\n\n\n\n\n::: {.cell}\n\n```{.markdown .cell-code}\nMean BMI was \n`r mean(nhanes.samp$BMI, na.rm=TRUE)|>round(1)`.\n```\n:::\n\n\n\n:::\n\n::: {.column width=\"50%\"}\n**✅ Clean:**\n\n\n\n\n::: {.cell}\n\n````{.markdown .cell-code}\n```{{r}}\n#| include: false\nm_bmi <- mean(nhanes.samp$BMI, \n              na.rm = TRUE) |> round(1)\n```\n\nMean BMI was `r m_bmi`.\n````\n:::\n\n\n\n:::\n:::\n\n\\\n\nThe chunk does the work. Inline R just reports it.\n\n---\n\n## Formatting Numbers Inline\n\nThe `scales` package formats numbers directly — no more `round()` or `paste0()`:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(scales)\n\nn      <- nrow(nhanes.samp)\nm_bmi  <- mean(nhanes.samp$BMI, na.rm = TRUE)\nsd_bmi <- sd(nhanes.samp$BMI, na.rm = TRUE)\n\nprop_overweight <- mean(nhanes.samp$BMI >= 25, na.rm = TRUE)\np_val <- 0.0003\n```\n:::\n\n\n\n\n\\\n\n\n\n\n::: {.cell}\n\n```{.markdown .cell-code}\nThe sample included `r n` participants.\nMean BMI was `r scales::number(m_bmi, accuracy = 0.1)` kg/m²\n(SD = `r scales::number(sd_bmi, accuracy = 0.1)`).\n`r scales::percent(prop_overweight, accuracy = 0.1)` had BMI ≥ 25.\nThe association was statistically significant (*p* `r scales::pvalue(p_val)`).\n```\n:::\n\n\n\n\n\\\n\nRenders as:\n\n> The sample included 200 participants. Mean BMI was 26.6 kg/m² (SD = 8.0). 54.7% had BMI ≥ 25. The association was statistically significant (*p* <0.001).\n\n. . .\n\nThe `accuracy` argument controls decimal places. `scales::pvalue()` automatically handles the `< 0.001` case.\n\n---\n\n\n\n## Putting It All Together {.section-slide}\n\n---\n\n## Before: The Fragile Report\n\n```markdown\n## Results\n\nWe analyzed data from 200 participants. The mean age was\n38.2 years (SD = 14.7). Mean BMI was 26.7 kg/m²\n(SD = 6.5). Approximately 60.4% of participants had a \nBMI ≥ 25.\n```\n\nEvery number here is hardcoded. If the dataset changes — or if you made an error — **you have to find every number manually.**\n\n---\n\n## After: The Reproducible Report\n\n\n\n\n\n\n::: {.cell}\n\n````{.markdown .cell-code}\n```{{r}}\n#| include: false\nn      <- nrow(nhanes.samp)\nm_age  <- mean(nhanes.samp$Age, na.rm = TRUE)\nsd_age <- sd(nhanes.samp$Age,   na.rm = TRUE)\nm_bmi  <- mean(nhanes.samp$BMI, na.rm = TRUE)\nsd_bmi <- sd(nhanes.samp$BMI,   na.rm = TRUE)\npct_ow <- scales::percent(mean(nhanes.samp$BMI >= 25, na.rm = TRUE),\n                           accuracy = 0.1)\n```\n\nWe analyzed data from `r n` participants. Mean age was\n`r scales::number(m_age, accuracy = 0.1)` years\n(SD = `r scales::number(sd_age, accuracy = 0.1)`). Mean BMI was\n`r scales::number(m_bmi, accuracy = 0.1)` kg/m²\n(SD = `r scales::number(sd_bmi, accuracy = 0.1)`).\nApproximately `r pct_ow` had a BMI ≥ 25.\n````\n:::\n\n\n\nRenders as:\n\n> We analyzed data from 200 participants. Mean age was 33.3 years (SD = 21.1). Mean BMI was 26.6 kg/m² (SD = 8.0). Approximately 54.7% had a BMI ≥ 25.\n\nRe-run with new data. **Everything updates.**\n\n---\n\n## Key Takeaways\n\n::: {.columns}\n::: {.column width=\"60%\"}\n**YAML**\n\n- Controls document settings and metadata\n- `execute:` sets defaults for all chunks\n- `self-contained: true` for easy submission\n\n**Chunk options**\n\n- `echo` / `eval` / `include` control visibility\n- Always label your chunks\n- Fig options control plot appearance\n\n**Inline R**\n\n- Never manually type a number that R can compute\n- Compute in a chunk, report inline\n- `scales` package for clean formatting\n:::\n\n::: {.column width=\"40%\"}\n::: {.callout-tip}\n**The rule:**\n\nIf a number in your prose came from an analysis, it should come from R — not from you typing it.\n:::\n:::\n:::\n\n---\n\n## References\n\n\\\n\n**YAML**\n\n- [Good intro to YAML](https://rpubs.com/drgregmartin/1266674) -- focus on \"Document YAML\" not \"Project YAML\".\n- [YAML in R for Data Science](https://r4ds.hadley.nz/quarto.html#yaml-header)\n- [Bootstrap themes](https://quarto.org/docs/output-formats/html-themes.html)\n\n\\\n\n**Chunk options**\n\n- [Global chunk options in Quarto](https://quarto.org/docs/computations/execution-options.html)\n- [Quarto chunk options](https://rpubs.com/drgregmartin/1266667)\n- [Quarto documentation: chunk options](https://quarto.org/docs/computations/r.html#chunk-options)\n\n\\\n\n**Inline R**\n\n- [Inline R Code in RMarkdown](https://uoepsy.github.io/scs/rmd-bootcamp/03-inline.html) -- Applies for Quarto too.\n- [Inline R code](https://yihui.org/rmarkdown-cookbook/r-code)\n- [Quarto documentation](https://quarto.org/docs/computations/inline-code.html) -- OK. Have to click on the \"Knitr\" tab to see `R`.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}