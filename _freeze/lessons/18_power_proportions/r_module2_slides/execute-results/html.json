{
  "hash": "3933f5b26a17f6f2b999caef00ba8eb9",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"R Module 2: Factors and Reshaping Data\"\nsubtitle: \"BMSC 620 | R Workflow Series\"\nauthor: \"Emile Latour\"\nformat:\n  revealjs:\n    theme: \"../../assets/css/reveal-bmsc620_v5.scss\"\n    slide-number: true\n    show-slide-number: all\n    width: 1955\n    height: 1100\n    footer: \"BMSC 620 | Factors and Reshaping Data\"\n    html-math-method: mathjax\n    chalkboard: true\n    progress: true\n    code-line-numbers: true\n    code-copy: true\n    highlight-style: github\n    fig-align: center\n    incremental: false\nexecute:\n  echo: true\n  warning: false\n  message: false\n---\n\n::: {.cell}\n\n:::\n\n\n\n## What We're Learning Today {.section-slide}\n\n::: {.learning-objectives}\nBy the end of this module, you will be able to:\n\n1. Understand the difference between **characters** and **factors** in R\n2. Use **forcats** functions to reorder and relabel factor levels\n3. Recognize when data is in **wide** vs. **long** format\n4. Use `pivot_longer()` and `pivot_wider()` to reshape data\n:::\n\n::: {.callout-note}\nThese skills come up constantly — every time you make a plot with categories or need to restructure data for analysis.\n:::\n\n---\n\n## Two Problems You've Probably Already Hit\n\n\\\n\n**Problem 1:** You make a bar chart and the categories are in alphabetical order instead of a meaningful order.\n\n. . .\n\n**Problem 2:** You have data with multiple columns that should really be rows (or vice versa) and your `ggplot()` code won't cooperate.\n\n. . .\n\n\\\n\nBoth problems have the same root cause: R doesn't know what you know about the **structure** of your data.\n\n. . .\n\nToday we fix that.\n\n---\n\n## Part 1: What Is a Factor? {.section-slide}\n\n---\n\n## The Motivating Bug\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nnhanes.samp %>%\n  filter(!is.na(HealthGen)) %>%\n  ggplot(aes(x = HealthGen)) +\n  geom_bar(fill = \"#0072B2\") +\n  labs(title = \"Self-Reported Health Ratings\",\n       subtitle = \"Alphabetical order makes no sense here!\",\n       x = \"Health Rating\",\n       y = \"Count\") + \n  theme_bw(base_size = 16)\n```\n\n::: {.cell-output-display}\n![](r_module2_slides_files/figure-revealjs/motivating-bug-1.png){fig-align='center' width=3000}\n:::\n:::\n\n\n\nThe categories are in **alphabetical order**. That's not what we want.\n\n---\n\n## Character vs. Factor\n\n::: {.columns}\n::: {.column width=\"50%\"}\n**Character**\n\n- Just text — R treats it like any string\n- No inherent order\n- Plotted alphabetically by default\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(nhanes.samp$HealthGen)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"character\"\n```\n\n\n:::\n:::\n\n\n:::\n\n::: {.column width=\"50%\"}\n**Factor**\n\n- A categorical variable with a **defined set of levels**\n- Levels have an **order** (even if it's arbitrary)\n- You control the order\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhealth_factor <- factor(nhanes.samp$HealthGen)\nclass(health_factor)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"factor\"\n```\n\n\n:::\n\n```{.r .cell-code}\nlevels(health_factor)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Excellent\" \"Fair\"      \"Good\"      \"Poor\"      \"Vgood\"    \n```\n\n\n:::\n:::\n\n\n:::\n:::\n\n. . .\n\n\\\n\nWhen R converts a character to a factor automatically, it uses **alphabetical order** — which is almost never what you want.\n\n---\n\n## Creating Factors with `factor()`\n\nYou can specify the exact order of levels:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnhanes.samp <- nhanes.samp %>%\n  mutate(\n    HealthGen = factor(HealthGen,\n                       levels = c(\"Excellent\",\n                                  \"Vgood\",\n                                  \"Good\",\n                                  \"Fair\",\n                                  \"Poor\")))\n\nlevels(nhanes.samp$HealthGen)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Excellent\" \"Vgood\"     \"Good\"      \"Fair\"      \"Poor\"     \n```\n\n\n:::\n:::\n\n\n\n\\\n\n::: {.callout-tip}\nThe `levels` argument defines the order. Categories not listed are set to `NA`.\n:::\n\n## Cleaning Up Labels with base R\n\n\"Vgood\" isn't great for a plot or a report. We can rename it:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Cleaning Up Labels\nnhanes.samp <- nhanes.samp %>%\n  mutate(\n    HealthGen = factor(HealthGen,\n                       levels = c(\"Excellent\", \"Vgood\", \"Good\", \"Fair\", \"Poor\"),\n                       labels = c(\"Excellent\", \"Very Good\", \"Good\", \"Fair\", \"Poor\"))\n  )\n\nlevels(nhanes.samp$HealthGen)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Excellent\" \"Very Good\" \"Good\"      \"Fair\"      \"Poor\"     \n```\n\n\n:::\n:::\n\n\n\n\n\n---\n\n## The Fix: Ordered Factor in a Plot\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nnhanes.samp %>%\n  filter(!is.na(HealthGen)) %>%\n  ggplot(aes(x = HealthGen)) +\n  geom_bar(fill = \"#0072B2\") +\n  labs(title = \"Self-Reported Health Ratings\",\n       subtitle = \"Now in a meaningful order with a clean label\",\n       x = \"Health Rating\",\n       y = \"Count\") +\n  theme_bw(base_size = 16)\n```\n\n::: {.cell-output-display}\n![](r_module2_slides_files/figure-revealjs/fix-plot-1.png){fig-align='center' width=3000}\n:::\n:::\n\n\n\n**Same code.** The only thing that changed was making `HealthGen` a factor with meaningful levels.\n\n---\n\n## `levels()` — Inspect and Verify\n\n`levels()` is your diagnostic tool — use it to check that your factor is set up correctly:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# What levels exist?\nlevels(nhanes.samp$HealthGen)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Excellent\" \"Very Good\" \"Good\"      \"Fair\"      \"Poor\"     \n```\n\n\n:::\n\n```{.r .cell-code}\n# How many levels?\nnlevels(nhanes.samp$HealthGen)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 5\n```\n\n\n:::\n:::\n\n\n\n\\\n\n::: {.callout-important}\nAlways check `levels()` after creating a factor. If the order isn't what you expect, fix it now — not after you've built plots and run models.\n:::\n\n---\n\n## Part 2: The `forcats` Package {.section-slide}\n\n---\n\n## Why `forcats`?\n\n`factor()` works, but it requires you to type out every level by hand. The `forcats` package (part of the tidyverse) gives you shortcut functions for common tasks:\n\n\\\n\n| Function | What it does |\n|----------|-------------|\n| `fct_relevel()` | Manually reorder specific levels |\n| `fct_reorder()` | Reorder levels by a summary statistic |\n| `fct_infreq()` | Order levels by frequency |\n| `fct_rev()` | Reverse the current order |\n| `fct_recode()` | Rename levels |\n| `fct_collapse()` | Combine levels into groups |\n\n\\\n\nWe'll focus on `fct_relevel()` and `fct_reorder()` — the two you'll use most.\n\n---\n\n## Education Is Already a Factor\n\n`Education` was already a factor in the dataset:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(nhanes.samp$Education)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"factor\"\n```\n\n\n:::\n\n```{.r .cell-code}\nlevels(nhanes.samp$Education)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"8th Grade\"      \"9 - 11th Grade\" \"High School\"    \"Some College\"  \n[5] \"College Grad\"  \n```\n\n\n:::\n:::\n\n\n\n\\\n\nThe levels are in a reasonable order — but what if we want to change the reference category for a model, or reorder by a statistic for a plot?\n\nThat's where `forcats` comes in.\n\n## `fct_relevel()` — Manual Reordering\n\nMove specific levels to the front, or place them at a specific position:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Move \"College Grad\" to the first position\nnhanes.samp %>%\n  mutate(Education = fct_relevel(Education, \"College Grad\")) %>%\n  pull(Education) %>%\n  levels()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"College Grad\"   \"8th Grade\"      \"9 - 11th Grade\" \"High School\"   \n[5] \"Some College\"  \n```\n\n\n:::\n:::\n\n\n\n\\\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Move \"College Grad\" to the last position\nnhanes.samp %>%\n  mutate(Education = fct_relevel(Education, \"College Grad\", after = Inf)) %>%\n  pull(Education) %>%\n  levels()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"8th Grade\"      \"9 - 11th Grade\" \"High School\"    \"Some College\"  \n[5] \"College Grad\"  \n```\n\n\n:::\n:::\n\n\n\n\\\n\n`after = Inf` is the trick for \"put it at the end.\"\n\n---\n\n## `fct_reorder()` — Data-Driven Reordering\n\nOrder factor levels by a **summary statistic** of another variable. This is especially powerful for plots:\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nnhanes.samp %>%\n  filter(!is.na(Education), !is.na(BMI)) %>%\n  mutate(Education = fct_reorder(Education, BMI, .fun = median)) %>%\n  ggplot(aes(x = Education, y = BMI)) +\n  geom_boxplot(fill = \"#0072B2\", alpha = 0.7) +\n  labs(title = \"BMI by education level (ordered by median BMI)\",\n       x = \"Education level\",\n       y = \"BMI (kg/m²)\") +\n  theme_bw(base_size = 16)\n```\n\n::: {.cell-output-display}\n![](r_module2_slides_files/figure-revealjs/fct-reorder-1.png){fig-align='center' width=3000}\n:::\n:::\n\n\n\n---\n\n## `fct_infreq()` — Order by Frequency\n\nSometimes you just want categories ordered by how often they appear:\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nnhanes.samp %>%\n  filter(!is.na(Education)) %>%\n  mutate(Education = fct_infreq(Education)) %>%\n  ggplot(aes(x = Education)) +\n  geom_bar(fill = \"#0072B2\") +\n  labs(title = \"Education levels ordered by frequency\",\n       x = \"Education level\",\n       y = \"Count\") +\n  theme_bw(base_size = 16)\n```\n\n::: {.cell-output-display}\n![](r_module2_slides_files/figure-revealjs/fct-infreq-1.png){fig-align='center' width=3000}\n:::\n:::\n\n\n\n\n## `fct_recode()` — Rename Levels\n\nSometimes level names are too long, abbreviated, or inconsistent. `fct_recode()` lets you rename them:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nunique(nhanes.samp$HealthGen)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] Fair      Very Good <NA>      Good      Excellent Poor     \nLevels: Excellent Very Good Good Fair Poor\n```\n\n\n:::\n\n```{.r .cell-code}\nnhanes.samp %>%\n  mutate(\n    Education = fct_recode(Education,\n                           \"Some HS\" = \"9 - 11th Grade\",\n                           \"HS Grad\" = \"High School\",\n                           \"College\" = \"College Grad\")\n  ) %>%\n  pull(Education) %>%\n  levels()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"8th Grade\"    \"Some HS\"      \"HS Grad\"      \"Some College\" \"College\"     \n```\n\n\n:::\n:::\n\n\n\n\n::: {.callout-note}\n- The syntax is `\"new name\" = \"old name\"`. It feels backwards at first, but it follows the same `left = right` assignment pattern as `mutate()`. Only the levels you list are renamed — the rest stay as they are.\n- Unlike the `labels` argument we used earlier, `fct_recode()` lets you pick and choose. If you only want to rename one category, the others will stay exactly as they were.\n:::\n\n---\n\n## Why Factors Matter for Modeling (Preview)\n\nWhen you fit a regression model, R automatically creates **dummy variables** from factors. The **first level** becomes the **reference category**.\n\n\\\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Current reference level (first in the list)\nlevels(nhanes.samp$Education)[1]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"8th Grade\"\n```\n\n\n:::\n:::\n\n\n\n\\\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Change reference to \"High School\"\nnhanes.samp %>%\n  mutate(Education = fct_relevel(Education, \"High School\")) %>%\n  pull(Education) %>%\n  levels()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"High School\"    \"8th Grade\"      \"9 - 11th Grade\" \"Some College\"  \n[5] \"College Grad\"  \n```\n\n\n:::\n:::\n\n\n\n\\\n\n::: {.callout-note}\nWe'll come back to this in detail when we cover regression. For now, just know that the **first factor level = reference category** in any model.\n:::\n\n---\n\n## Factor Tools Summary\n\n::: {.columns}\n::: {.column width=\"50%\"}\n**Creating factors**\n\n- `factor(x, levels = c(...))` — full control\n- `levels()` — inspect the result\n- Always verify your levels are correct\n\n**Common tasks**\n\n- Reorder for plots → `fct_reorder()` or `fct_infreq()`\n- Set reference level for modeling → `fct_relevel()`\n- Rename levels → `fct_recode()`\n:::\n\n::: {.column width=\"50%\"}\n::: {.callout-tip}\n**The rule of thumb:**\n\n- **For plots:** use `fct_reorder()` to order by a statistic, or `fct_infreq()` to order by count\n- **For models:** use `fct_relevel()` to set your reference category\n:::\n:::\n:::\n\n---\n\n## Part 3: Wide vs. Long Data {.section-slide}\n\n---\n\n## The Conceptual Shift\n\nMost data you receive is in **wide** format — one row per subject, multiple measurement columns.\n\nBut many R operations (especially `ggplot2`) need data in **long** format — one row per observation.\n\n. . .\n\n\\\n\n::: {.callout-note}\nThis is not about right vs. wrong. It's about which shape your tool expects.\n:::\n\n---\n\n## What Does \"Wide\" Data Look Like?\n\nEach subject is **one row**, with measurements spread across columns:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnhanes_wide <- nhanes.samp %>%\n  select(ID, Age, BMI, BPSysAve, BPDiaAve) %>%\n  head(5)\n\nnhanes_wide\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 × 5\n     ID   Age   BMI BPSysAve BPDiaAve\n  <int> <int> <dbl>    <int>    <int>\n1 63147    41  30        112       76\n2 67852    15  19.2      107       72\n3 57165    48  27.4      123       69\n4 68691     7  17.4       NA       NA\n5 69465    50  26.9      152      103\n```\n\n\n:::\n:::\n\n\n\n\\\n\nFour measurement columns: `Age`, `BMI`, `BPSysAve`, `BPDiaAve`. This is the shape you're used to seeing.\n\n---\n\n## What Does \"Long\" Data Look Like?\n\nEach measurement is **its own row**:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnhanes_long <- nhanes_wide %>%\n  pivot_longer(\n    cols = c(Age, BMI, BPSysAve, BPDiaAve),\n    names_to = \"measure\",\n    values_to = \"value\"\n  )\n\nnhanes_long\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 20 × 3\n      ID measure  value\n   <int> <chr>    <dbl>\n 1 63147 Age       41  \n 2 63147 BMI       30  \n 3 63147 BPSysAve 112  \n 4 63147 BPDiaAve  76  \n 5 67852 Age       15  \n 6 67852 BMI       19.2\n 7 67852 BPSysAve 107  \n 8 67852 BPDiaAve  72  \n 9 57165 Age       48  \n10 57165 BMI       27.4\n11 57165 BPSysAve 123  \n12 57165 BPDiaAve  69  \n13 68691 Age        7  \n14 68691 BMI       17.4\n15 68691 BPSysAve  NA  \n16 68691 BPDiaAve  NA  \n17 69465 Age       50  \n18 69465 BMI       26.9\n19 69465 BPSysAve 152  \n20 69465 BPDiaAve 103  \n```\n\n\n:::\n:::\n\n\n\n\\\n\nSame data, different shape. Each subject now has **4 rows** instead of 1.\n\n## Visualizing the Transformation (1/2)\n\n![](tidy-long-wide.png){fig-align=\"center\"}\n\n[Visual by Garrick Aden-Buie/tidyexplain](https://www.garrickadenbuie.com/project/tidyexplain/#spread-and-gather){.small style=\"font-size: 0.5em; color: gray;\"}\n\n## Visualizing the Transformation (2/2)\n\n![](tidyr-longer-wider-still.png){fig-align=\"center\"}\n<!-- ![](tidyr-longer-wider.gif) -->\n\n\n\n\n---\n\n## Why Does the Shape Matter?\n\n::: {.columns}\n::: {.column width=\"50%\"}\n**Wide format is good for:**\n\n- Human readability\n- Summary tables\n- Spreadsheet-style work\n- Most statistical tests in R\n:::\n\n::: {.column width=\"50%\"}\n**Long format is good for:**\n\n- `ggplot2` — faceting, color mapping\n- Grouped operations with `group_by()`\n- Repeated measures analysis\n- Any time you want to treat variable names as data\n:::\n:::\n\n. . .\n\n\\\n\n::: {.callout-important}\n**ggplot2's golden rule:** if you want different variables to be distinguished by color, facet, or grouping, they usually need to be in the **same column** — which means long format.\n:::\n\n---\n\n## Part 4: Pivoting {.section-slide}\n\n---\n\n## `pivot_longer()` — Wide to Long\n\n`pivot_longer()` takes multiple columns and stacks them into two new columns: one for the **variable names** and one for the **values**.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnhanes.samp %>%\n  select(ID, BMI, BPSysAve, BPDiaAve) %>%\n  head(4) %>%\n  pivot_longer(\n    cols = c(BMI, BPSysAve, BPDiaAve),        # columns to stack\n    names_to = \"measurement\",        # new column for variable names\n    values_to = \"value\"              # new column for the values\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 12 × 3\n      ID measurement value\n   <int> <chr>       <dbl>\n 1 63147 BMI          30  \n 2 63147 BPSysAve    112  \n 3 63147 BPDiaAve     76  \n 4 67852 BMI          19.2\n 5 67852 BPSysAve    107  \n 6 67852 BPDiaAve     72  \n 7 57165 BMI          27.4\n 8 57165 BPSysAve    123  \n 9 57165 BPDiaAve     69  \n10 68691 BMI          17.4\n11 68691 BPSysAve     NA  \n12 68691 BPDiaAve     NA  \n```\n\n\n:::\n:::\n\n\n\n---\n\n## `pivot_longer()` — The Three Arguments\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npivot_longer(\n  cols = c(BMI, BPSysAve, BPDiaAve),    # 1. Which columns to pivot\n  names_to = \"measurement\",             # 2. Name for the new \"names\" column\n  values_to = \"value\"                   # 3. Name for the new \"values\" column\n)\n```\n:::\n\n\n\n\\\n\n| Argument | Question it answers |\n|----------|-------------------|\n| `cols` | Which columns are being stacked? |\n| `names_to` | What should we call the column that holds the old column names? |\n| `values_to` | What should we call the column that holds the values? |\n\n\\\n\n::: {.callout-tip}\nThink of it as: \"I want to make this data **longer** by stacking these columns.\"\n:::\n\n---\n\n## `pivot_longer()` — Why the Dimensions Change\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnhanes_subset <- nhanes.samp %>%\n  select(ID, BMI, BPSysAve, BPDiaAve)\n\n# Wide: one row per subject\ndim(nhanes_subset)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 200   4\n```\n\n\n:::\n\n```{.r .cell-code}\n# Long: one row per subject × measurement\nnhanes_subset %>%\n  pivot_longer(cols = c(BMI, BPSysAve, BPDiaAve),\n               names_to = \"measurement\",\n               values_to = \"value\") %>%\n  dim()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 600   3\n```\n\n\n:::\n:::\n\n\n\n\\\n\nWe pivoted **3 columns**, so we get **3× the rows** and go from 4 columns down to 3 (ID + the two new columns).\n\n---\n\n## `pivot_wider()` — Long to Wide\n\n`pivot_wider()` does the reverse — it spreads rows back into columns:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnhanes_long_example <- nhanes.samp %>%\n  select(ID, BMI, BPSysAve, BPDiaAve) %>%\n  head(4) %>%\n  pivot_longer(cols = c(BMI, BPSysAve, BPDiaAve),\n               names_to = \"measurement\",\n               values_to = \"value\")\n\n# Now spread it back to wide\nnhanes_long_example %>%\n  pivot_wider(\n    names_from = \"measurement\",     # column whose values become new column names\n    values_from = \"value\"           # column whose values fill the new columns\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 × 4\n     ID   BMI BPSysAve BPDiaAve\n  <int> <dbl>    <dbl>    <dbl>\n1 63147  30        112       76\n2 67852  19.2      107       72\n3 57165  27.4      123       69\n4 68691  17.4       NA       NA\n```\n\n\n:::\n:::\n\n\n\n---\n\n## `pivot_wider()` — The Two Arguments\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npivot_wider(\n  names_from = \"measurement\",    # 1. Which column has the new column names?\n  values_from = \"value\"          # 2. Which column has the values to fill in?\n)\n```\n:::\n\n\n\n\\\n\n| Argument | Question it answers |\n|----------|-------------------|\n| `names_from` | Which column's values should become new column names? |\n| `values_from` | Which column's values should fill those new columns? |\n\n\\\n\n::: {.callout-tip}\nThink of it as: \"I want to make this data **wider** by spreading this column into multiple columns.\"\n:::\n\n---\n\n## Putting It Together: Pivot → Plot {.section-slide}\n\n---\n\n## A Three-Step Workflow\n\nSuppose we want to compare the distributions of `BMI`, `BPSysAve`, and `BPDiaAve` side by side. In wide format, this is awkward. In long format, it's one `ggplot()` call:\n\n**Step 1:** Select the relevant columns\n\n**Step 2:** Pivot to long format\n\n**Step 3:** Plot with faceting\n\n---\n\n## Pivot → Plot in Action\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nnhanes.samp %>%\n  select(ID, BMI, BPSysAve, BPDiaAve) %>%\n  pivot_longer(\n    cols = c(BMI, BPSysAve, BPDiaAve),\n    names_to = \"measurement\",\n    values_to = \"value\"\n  ) %>%\n  ggplot(aes(x = value)) +\n  geom_histogram(bins = 30, fill = \"#0072B2\", color = \"white\") +\n  facet_wrap(~ measurement, scales = \"free\") +\n  labs(title = \"Distributions of BMI, BPSysAve, and BPDiaAve\",\n       x = \"Value\",\n       y = \"Count\") +\n  theme_bw(base_size = 16)\n```\n\n::: {.cell-output-display}\n![](r_module2_slides_files/figure-revealjs/pivot-plot-1.png){fig-align='center' width=3600}\n:::\n:::\n\n\n\n\\\n\n**One pipeline. Three plots.** This is why reshaping matters.\n\n---\n\n## Key Takeaways\n\n::: {.columns}\n::: {.column width=\"60%\"}\n**Factors**\n\n- Characters have no order — factors do\n- `factor(x, levels = ...)` for full control\n- `fct_reorder()` for data-driven plot ordering\n- `fct_relevel()` to set reference categories\n\n**Reshaping**\n\n- Wide = one row per subject, many measurement columns\n- Long = one row per observation\n- `pivot_longer()` — wide to long (for plotting, grouping)\n- `pivot_wider()` — long to wide (for tables, summaries)\n:::\n\n::: {.column width=\"40%\"}\n::: {.callout-tip}\n**The rules:**\n\n**Factors:** If your plot categories are in the wrong order, it's a factor problem.\n\n**Reshaping:** If `ggplot` wants your data in a different shape, pivot it.\n:::\n:::\n:::\n\n---\n\n## References\n\n\\\n\n**Factors**\n\n- [R for Data Science: Factors](https://r4ds.hadley.nz/factors)\n- [forcats documentation](https://forcats.tidyverse.org/)\n- [Be the boss of your factors](https://stat545.com/factors-boss.html) — STAT 545\n\n\\\n\n**Reshaping data**\n\n- [R for Data Science: Pivoting](https://r4ds.hadley.nz/data-tidy.html#sec-pivoting)\n- [tidyr documentation](https://tidyr.tidyverse.org/articles/pivot.html)\n- [Pivoting vignette](https://tidyr.tidyverse.org/articles/pivot.html) — excellent visual explanations\n",
    "supporting": [
      "r_module2_slides_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}